CCS PCM C Compiler, Version 5.093, 4770               05-Mar-24 20:35

               Filename:   C:\Users\52312\Documents\Actual\instrumentacion\practica7\p7.lst

               ROM used:   2143 words (26%)
                           Largest free fragment is 2048
               RAM used:   43 (12%) at main() level
                           75 (20%) worst case
               Stack used: 7 locations (5 in main + 2 for interrupts)
               Stack size: 8

0000:  MOVLW  08
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  BTFSS  0B.4
0028:  GOTO   02B
0029:  BTFSC  0B.1
002A:  GOTO   056
002B:  MOVLW  8C
002C:  MOVWF  04
002D:  BTFSS  00.5
002E:  GOTO   031
002F:  BTFSC  0C.5
0030:  GOTO   059
0031:  BTFSS  0B.5
0032:  GOTO   035
0033:  BTFSC  0B.2
0034:  GOTO   05C
0035:  MOVF   22,W
0036:  MOVWF  04
0037:  MOVF   23,W
0038:  MOVWF  77
0039:  MOVF   24,W
003A:  MOVWF  78
003B:  MOVF   25,W
003C:  MOVWF  79
003D:  MOVF   26,W
003E:  MOVWF  7A
003F:  MOVF   27,W
0040:  BSF    03.6
0041:  MOVWF  0D
0042:  BCF    03.6
0043:  MOVF   28,W
0044:  BSF    03.6
0045:  MOVWF  0F
0046:  BCF    03.6
0047:  MOVF   29,W
0048:  BSF    03.6
0049:  MOVWF  0C
004A:  BCF    03.6
004B:  MOVF   2A,W
004C:  BSF    03.6
004D:  MOVWF  0E
004E:  BCF    03.6
004F:  MOVF   20,W
0050:  MOVWF  0A
0051:  SWAPF  21,W
0052:  MOVWF  03
0053:  SWAPF  7F,F
0054:  SWAPF  7F,W
0055:  RETFIE
0056:  BCF    0A.3
0057:  BCF    0A.4
0058:  GOTO   05F
0059:  BCF    0A.3
005A:  BCF    0A.4
005B:  GOTO   107
005C:  BCF    0A.3
005D:  BCF    0A.4
005E:  GOTO   0A5
.................... #INCLUDE <16F877a.h>
.................... //////////// Standard Header file for the PIC16F877A device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC16F877A
*
0066:  MOVF   5D,W
0067:  MOVWF  64
0068:  MOVF   61,W
0069:  XORWF  64,F
006A:  BTFSS  64.7
006B:  GOTO   071
006C:  BCF    03.2
006D:  BCF    03.0
006E:  BTFSC  5D.7
006F:  BSF    03.0
0070:  GOTO   0A4
0071:  MOVF   5D,W
0072:  MOVWF  64
0073:  MOVF   60,W
0074:  MOVWF  65
0075:  MOVF   5C,W
0076:  SUBWF  65,F
0077:  BTFSC  03.2
0078:  GOTO   07F
0079:  BTFSS  64.7
007A:  GOTO   0A4
007B:  MOVF   03,W
007C:  XORLW  01
007D:  MOVWF  03
007E:  GOTO   0A4
007F:  MOVF   61,W
0080:  MOVWF  65
0081:  MOVF   5D,W
0082:  SUBWF  65,F
0083:  BTFSC  03.2
0084:  GOTO   08B
0085:  BTFSS  64.7
0086:  GOTO   0A4
0087:  MOVF   03,W
0088:  XORLW  01
0089:  MOVWF  03
008A:  GOTO   0A4
008B:  MOVF   62,W
008C:  MOVWF  65
008D:  MOVF   5E,W
008E:  SUBWF  65,F
008F:  BTFSC  03.2
0090:  GOTO   097
0091:  BTFSS  64.7
0092:  GOTO   0A4
0093:  MOVF   03,W
0094:  XORLW  01
0095:  MOVWF  03
0096:  GOTO   0A4
0097:  MOVF   63,W
0098:  MOVWF  65
0099:  MOVF   5F,W
009A:  SUBWF  65,F
009B:  BTFSC  03.2
009C:  GOTO   0A3
009D:  BTFSS  64.7
009E:  GOTO   0A4
009F:  MOVF   03,W
00A0:  XORLW  01
00A1:  MOVWF  03
00A2:  GOTO   0A4
00A3:  BCF    03.0
00A4:  RETURN
*
00EA:  MOVLW  8E
00EB:  MOVWF  77
00EC:  MOVF   5D,W
00ED:  MOVWF  78
00EE:  MOVF   5C,W
00EF:  MOVWF  79
00F0:  CLRF   7A
00F1:  MOVF   78,F
00F2:  BTFSS  03.2
00F3:  GOTO   0FE
00F4:  MOVF   79,W
00F5:  MOVWF  78
00F6:  CLRF   79
00F7:  MOVLW  08
00F8:  SUBWF  77,F
00F9:  MOVF   78,F
00FA:  BTFSS  03.2
00FB:  GOTO   0FE
00FC:  CLRF   77
00FD:  GOTO   106
00FE:  BCF    03.0
00FF:  BTFSC  78.7
0100:  GOTO   105
0101:  RLF    79,F
0102:  RLF    78,F
0103:  DECF   77,F
0104:  GOTO   0FE
0105:  BCF    78.7
0106:  RETURN
*
0121:  DATA C1,21
0122:  DATA A0,26
0123:  DATA 4F,2A
0124:  DATA 4F,29
0125:  DATA A0,21
0126:  DATA 4F,27
0127:  DATA 54,29
0128:  DATA 4F,26
0129:  DATA 20,05
012A:  DATA CD,30
012B:  DATA 78,10
012C:  DATA 52,28
012D:  DATA 4D,1D
012E:  DATA B3,1A
012F:  DATA 30,18
0130:  DATA 00,00
0131:  DATA 0C,22
0132:  DATA 75,3A
0133:  DATA 79,10
0134:  DATA C3,34
0135:  DATA 63,36
0136:  DATA 65,1D
0137:  DATA A0,12
0138:  DATA 6C,33
0139:  DATA 20,05
013A:  DATA 52,28
013B:  DATA 4D,1D
013C:  DATA A0,12
013D:  DATA 66,00
013E:  DATA 0C,22
013F:  DATA 43,1D
0140:  DATA A0,12
0141:  DATA 6C,33
0142:  DATA 20,05
0143:  DATA 52,28
0144:  DATA 4D,1D
0145:  DATA A0,12
0146:  DATA E6,18
0147:  DATA AE,18
0148:  DATA 00,00
*
02CC:  MOVF   0B,W
02CD:  MOVWF  42
02CE:  BCF    0B.7
02CF:  BSF    03.5
02D0:  BSF    03.6
02D1:  BSF    0C.7
02D2:  BSF    0C.0
02D3:  NOP
02D4:  NOP
02D5:  BCF    03.5
02D6:  BCF    03.6
02D7:  BTFSC  42.7
02D8:  BSF    0B.7
02D9:  BSF    03.6
02DA:  MOVF   0C,W
02DB:  ANDLW  7F
02DC:  BTFSC  03.2
02DD:  GOTO   320
02DE:  BCF    03.6
02DF:  MOVWF  42
02E0:  BSF    03.6
02E1:  MOVF   0D,W
02E2:  BCF    03.6
02E3:  MOVWF  43
02E4:  BSF    03.6
02E5:  MOVF   0F,W
02E6:  BCF    03.6
02E7:  MOVWF  44
02E8:  MOVF   42,W
02E9:  MOVWF  4F
02EA:  CALL   2A0
02EB:  MOVF   43,W
02EC:  BSF    03.6
02ED:  MOVWF  0D
02EE:  BCF    03.6
02EF:  MOVF   44,W
02F0:  BSF    03.6
02F1:  MOVWF  0F
02F2:  BCF    03.6
02F3:  MOVF   0B,W
02F4:  MOVWF  45
02F5:  BCF    0B.7
02F6:  BSF    03.5
02F7:  BSF    03.6
02F8:  BSF    0C.7
02F9:  BSF    0C.0
02FA:  NOP
02FB:  NOP
02FC:  BCF    03.5
02FD:  BCF    03.6
02FE:  BTFSC  45.7
02FF:  BSF    0B.7
0300:  BSF    03.6
0301:  RLF    0C,W
0302:  RLF    0E,W
0303:  ANDLW  7F
0304:  BTFSC  03.2
0305:  GOTO   320
0306:  BCF    03.6
0307:  MOVWF  42
0308:  BSF    03.6
0309:  MOVF   0D,W
030A:  BCF    03.6
030B:  MOVWF  43
030C:  BSF    03.6
030D:  MOVF   0F,W
030E:  BCF    03.6
030F:  MOVWF  44
0310:  MOVF   42,W
0311:  MOVWF  4F
0312:  CALL   2A0
0313:  MOVF   43,W
0314:  BSF    03.6
0315:  MOVWF  0D
0316:  BCF    03.6
0317:  MOVF   44,W
0318:  BSF    03.6
0319:  MOVWF  0F
031A:  INCF   0D,F
031B:  BTFSC  03.2
031C:  INCF   0F,F
031D:  BCF    03.6
031E:  GOTO   2CC
031F:  BSF    03.6
0320:  BCF    03.6
0321:  BSF    0A.3
0322:  BCF    0A.4
0323:  GOTO   047 (RETURN)
0324:  MOVF   0B,W
0325:  MOVWF  43
0326:  BCF    0B.7
0327:  BSF    03.5
0328:  BSF    03.6
0329:  BSF    0C.7
032A:  BSF    0C.0
032B:  NOP
032C:  NOP
032D:  BCF    03.5
032E:  BCF    03.6
032F:  BTFSC  43.7
0330:  BSF    0B.7
0331:  BTFSC  03.0
0332:  GOTO   35B
0333:  BSF    03.6
0334:  MOVF   0C,W
0335:  ANDLW  7F
0336:  BCF    03.6
0337:  MOVWF  43
0338:  BSF    03.6
0339:  MOVF   0D,W
033A:  BCF    03.6
033B:  MOVWF  44
033C:  BSF    03.6
033D:  MOVF   0F,W
033E:  BCF    03.6
033F:  MOVWF  45
0340:  MOVF   43,W
0341:  MOVWF  4F
0342:  CALL   2A0
0343:  MOVF   44,W
0344:  BSF    03.6
0345:  MOVWF  0D
0346:  BCF    03.6
0347:  MOVF   45,W
0348:  BSF    03.6
0349:  MOVWF  0F
034A:  BCF    03.6
034B:  MOVF   0B,W
034C:  MOVWF  46
034D:  BCF    0B.7
034E:  BSF    03.5
034F:  BSF    03.6
0350:  BSF    0C.7
0351:  BSF    0C.0
0352:  NOP
0353:  NOP
0354:  BCF    03.5
0355:  BCF    03.6
0356:  BTFSC  46.7
0357:  BSF    0B.7
0358:  DECFSZ 42,F
0359:  GOTO   35B
035A:  GOTO   37A
035B:  BSF    03.6
035C:  RLF    0C,W
035D:  RLF    0E,W
035E:  ANDLW  7F
035F:  BCF    03.6
0360:  MOVWF  43
0361:  BSF    03.6
0362:  MOVF   0D,W
0363:  BCF    03.6
0364:  MOVWF  44
0365:  BSF    03.6
0366:  MOVF   0F,W
0367:  BCF    03.6
0368:  MOVWF  45
0369:  MOVF   43,W
036A:  MOVWF  4F
036B:  CALL   2A0
036C:  MOVF   44,W
036D:  BSF    03.6
036E:  MOVWF  0D
036F:  BCF    03.6
0370:  MOVF   45,W
0371:  BSF    03.6
0372:  MOVWF  0F
0373:  INCF   0D,F
0374:  BTFSC  03.2
0375:  INCF   0F,F
0376:  BCF    03.0
0377:  BCF    03.6
0378:  DECFSZ 42,F
0379:  GOTO   324
037A:  RETURN
037B:  MOVF   4F,W
037C:  BTFSC  03.2
037D:  GOTO   3EB
037E:  MOVWF  57
037F:  MOVF   53,W
0380:  BTFSC  03.2
0381:  GOTO   3EB
0382:  ADDWF  57,F
0383:  BTFSC  03.0
0384:  GOTO   38C
0385:  MOVLW  7F
0386:  SUBWF  57,F
0387:  BTFSS  03.0
0388:  GOTO   3EB
0389:  BTFSC  03.2
038A:  GOTO   3EB
038B:  GOTO   390
038C:  MOVLW  81
038D:  ADDWF  57,F
038E:  BTFSC  03.0
038F:  GOTO   3EB
0390:  MOVF   57,W
0391:  MOVWF  77
0392:  CLRF   78
0393:  CLRF   79
0394:  CLRF   7A
0395:  MOVF   50,W
0396:  MOVWF  5B
0397:  BSF    5B.7
0398:  MOVF   51,W
0399:  MOVWF  5A
039A:  MOVF   52,W
039B:  MOVWF  59
039C:  MOVLW  18
039D:  MOVWF  57
039E:  CLRF   58
039F:  BTFSS  59.0
03A0:  GOTO   3B9
03A1:  MOVF   56,W
03A2:  ADDWF  7A,F
03A3:  BTFSS  03.0
03A4:  GOTO   3AB
03A5:  INCF   79,F
03A6:  BTFSS  03.2
03A7:  GOTO   3AB
03A8:  INCF   78,F
03A9:  BTFSC  03.2
03AA:  BSF    58.7
03AB:  MOVF   55,W
03AC:  ADDWF  79,F
03AD:  BTFSS  03.0
03AE:  GOTO   3B2
03AF:  INCF   78,F
03B0:  BTFSC  03.2
03B1:  BSF    58.7
03B2:  MOVF   54,W
03B3:  MOVWF  51
03B4:  BSF    51.7
03B5:  MOVF   51,W
03B6:  ADDWF  78,F
03B7:  BTFSC  03.0
03B8:  BSF    58.7
03B9:  RLF    58,F
03BA:  RRF    78,F
03BB:  RRF    79,F
03BC:  RRF    7A,F
03BD:  RRF    5B,F
03BE:  RRF    5A,F
03BF:  RRF    59,F
03C0:  BCF    03.0
03C1:  DECFSZ 57,F
03C2:  GOTO   39E
03C3:  MOVLW  01
03C4:  ADDWF  77,F
03C5:  BTFSC  03.0
03C6:  GOTO   3EB
03C7:  BTFSC  78.7
03C8:  GOTO   3D0
03C9:  RLF    5B,F
03CA:  RLF    7A,F
03CB:  RLF    79,F
03CC:  RLF    78,F
03CD:  DECF   77,F
03CE:  BTFSC  03.2
03CF:  GOTO   3EB
03D0:  BTFSS  5B.7
03D1:  GOTO   3E1
03D2:  INCF   7A,F
03D3:  BTFSS  03.2
03D4:  GOTO   3E1
03D5:  INCF   79,F
03D6:  BTFSS  03.2
03D7:  GOTO   3E1
03D8:  INCF   78,F
03D9:  BTFSS  03.2
03DA:  GOTO   3E1
03DB:  RRF    78,F
03DC:  RRF    79,F
03DD:  RRF    7A,F
03DE:  INCF   77,F
03DF:  BTFSC  03.2
03E0:  GOTO   3EB
03E1:  MOVF   50,W
03E2:  MOVWF  58
03E3:  MOVF   54,W
03E4:  XORWF  58,F
03E5:  BTFSS  58.7
03E6:  GOTO   3E9
03E7:  BSF    78.7
03E8:  GOTO   3EF
03E9:  BCF    78.7
03EA:  GOTO   3EF
03EB:  CLRF   77
03EC:  CLRF   78
03ED:  CLRF   79
03EE:  CLRF   7A
03EF:  RETURN
03F0:  MOVF   4F,W
03F1:  SUBLW  B6
03F2:  MOVWF  4F
03F3:  CLRF   7A
03F4:  MOVF   50,W
03F5:  MOVWF  53
03F6:  BSF    50.7
03F7:  BCF    03.0
03F8:  RRF    50,F
03F9:  RRF    51,F
03FA:  RRF    52,F
03FB:  RRF    7A,F
03FC:  RRF    79,F
03FD:  RRF    78,F
03FE:  RRF    77,F
03FF:  DECFSZ 4F,F
0400:  GOTO   3F7
0401:  BTFSS  53.7
0402:  GOTO   40E
0403:  COMF   77,F
0404:  COMF   78,F
0405:  COMF   79,F
0406:  COMF   7A,F
0407:  INCF   77,F
0408:  BTFSC  03.2
0409:  INCF   78,F
040A:  BTFSC  03.2
040B:  INCF   79,F
040C:  BTFSC  03.2
040D:  INCF   7A,F
040E:  RETURN
040F:  BTFSC  03.1
0410:  GOTO   414
0411:  MOVLW  57
0412:  MOVWF  04
0413:  BCF    03.7
0414:  CLRF   77
0415:  CLRF   78
0416:  CLRF   79
0417:  CLRF   7A
0418:  CLRF   57
0419:  CLRF   58
041A:  CLRF   59
041B:  CLRF   5A
041C:  MOVF   56,W
041D:  IORWF  55,W
041E:  IORWF  54,W
041F:  IORWF  53,W
0420:  BTFSC  03.2
0421:  GOTO   452
0422:  MOVLW  20
0423:  MOVWF  5B
0424:  BCF    03.0
0425:  RLF    4F,F
0426:  RLF    50,F
0427:  RLF    51,F
0428:  RLF    52,F
0429:  RLF    57,F
042A:  RLF    58,F
042B:  RLF    59,F
042C:  RLF    5A,F
042D:  MOVF   56,W
042E:  SUBWF  5A,W
042F:  BTFSS  03.2
0430:  GOTO   43B
0431:  MOVF   55,W
0432:  SUBWF  59,W
0433:  BTFSS  03.2
0434:  GOTO   43B
0435:  MOVF   54,W
0436:  SUBWF  58,W
0437:  BTFSS  03.2
0438:  GOTO   43B
0439:  MOVF   53,W
043A:  SUBWF  57,W
043B:  BTFSS  03.0
043C:  GOTO   44C
043D:  MOVF   53,W
043E:  SUBWF  57,F
043F:  MOVF   54,W
0440:  BTFSS  03.0
0441:  INCFSZ 54,W
0442:  SUBWF  58,F
0443:  MOVF   55,W
0444:  BTFSS  03.0
0445:  INCFSZ 55,W
0446:  SUBWF  59,F
0447:  MOVF   56,W
0448:  BTFSS  03.0
0449:  INCFSZ 56,W
044A:  SUBWF  5A,F
044B:  BSF    03.0
044C:  RLF    77,F
044D:  RLF    78,F
044E:  RLF    79,F
044F:  RLF    7A,F
0450:  DECFSZ 5B,F
0451:  GOTO   424
0452:  MOVF   57,W
0453:  MOVWF  00
0454:  INCF   04,F
0455:  MOVF   58,W
0456:  MOVWF  00
0457:  INCF   04,F
0458:  MOVF   59,W
0459:  MOVWF  00
045A:  INCF   04,F
045B:  MOVF   5A,W
045C:  MOVWF  00
045D:  RETURN
045E:  MOVF   04,W
045F:  MOVWF  47
0460:  MOVF   46,W
0461:  MOVWF  49
0462:  BTFSC  03.2
0463:  GOTO   47D
0464:  MOVF   45,W
0465:  MOVWF  52
0466:  MOVF   44,W
0467:  MOVWF  51
0468:  MOVF   43,W
0469:  MOVWF  50
046A:  MOVF   42,W
046B:  MOVWF  4F
046C:  CLRF   56
046D:  CLRF   55
046E:  MOVLW  20
046F:  MOVWF  54
0470:  MOVLW  82
0471:  MOVWF  53
0472:  CALL   37B
0473:  MOVF   7A,W
0474:  MOVWF  45
0475:  MOVF   79,W
0476:  MOVWF  44
0477:  MOVF   78,W
0478:  MOVWF  43
0479:  MOVF   77,W
047A:  MOVWF  42
047B:  DECFSZ 49,F
047C:  GOTO   464
047D:  MOVF   45,W
047E:  MOVWF  52
047F:  MOVF   44,W
0480:  MOVWF  51
0481:  MOVF   43,W
0482:  MOVWF  50
0483:  MOVF   42,W
0484:  MOVWF  4F
0485:  CALL   3F0
0486:  MOVF   7A,W
0487:  MOVWF  45
0488:  MOVF   79,W
0489:  MOVWF  44
048A:  MOVF   78,W
048B:  MOVWF  43
048C:  MOVF   77,W
048D:  MOVWF  42
048E:  BTFSS  45.7
048F:  GOTO   49D
0490:  DECF   47,F
0491:  BSF    47.5
0492:  COMF   42,F
0493:  COMF   43,F
0494:  COMF   44,F
0495:  COMF   45,F
0496:  INCF   42,F
0497:  BTFSC  03.2
0498:  INCF   43,F
0499:  BTFSC  03.2
049A:  INCF   44,F
049B:  BTFSC  03.2
049C:  INCF   45,F
049D:  MOVLW  3B
049E:  MOVWF  4E
049F:  MOVLW  9A
04A0:  MOVWF  4D
04A1:  MOVLW  CA
04A2:  MOVWF  4C
04A3:  CLRF   4B
04A4:  MOVLW  0A
04A5:  MOVWF  49
04A6:  MOVF   46,W
04A7:  BTFSC  03.2
04A8:  INCF   47,F
04A9:  BSF    03.1
04AA:  MOVLW  42
04AB:  MOVWF  04
04AC:  BCF    03.7
04AD:  MOVF   45,W
04AE:  MOVWF  52
04AF:  MOVF   44,W
04B0:  MOVWF  51
04B1:  MOVF   43,W
04B2:  MOVWF  50
04B3:  MOVF   42,W
04B4:  MOVWF  4F
04B5:  MOVF   4E,W
04B6:  MOVWF  56
04B7:  MOVF   4D,W
04B8:  MOVWF  55
04B9:  MOVF   4C,W
04BA:  MOVWF  54
04BB:  MOVF   4B,W
04BC:  MOVWF  53
04BD:  CALL   40F
04BE:  MOVF   78,W
04BF:  MOVF   77,F
04C0:  BTFSS  03.2
04C1:  GOTO   4D5
04C2:  INCF   46,W
04C3:  SUBWF  49,W
04C4:  BTFSC  03.2
04C5:  GOTO   4D5
04C6:  MOVF   47,W
04C7:  BTFSC  03.2
04C8:  GOTO   4D7
04C9:  ANDLW  0F
04CA:  SUBWF  49,W
04CB:  BTFSC  03.2
04CC:  GOTO   4CF
04CD:  BTFSC  03.0
04CE:  GOTO   507
04CF:  BTFSC  47.7
04D0:  GOTO   507
04D1:  BTFSC  47.6
04D2:  GOTO   4D7
04D3:  MOVLW  20
04D4:  GOTO   503
04D5:  MOVLW  20
04D6:  ANDWF  47,F
04D7:  BTFSS  47.5
04D8:  GOTO   4E5
04D9:  BCF    47.5
04DA:  MOVF   46,W
04DB:  BTFSS  03.2
04DC:  DECF   47,F
04DD:  MOVF   77,W
04DE:  MOVWF  47
04DF:  MOVLW  2D
04E0:  MOVWF  4F
04E1:  CALL   2A0
04E2:  MOVF   47,W
04E3:  MOVWF  77
04E4:  CLRF   47
04E5:  MOVF   46,W
04E6:  SUBWF  49,W
04E7:  BTFSS  03.2
04E8:  GOTO   4F3
04E9:  MOVF   77,W
04EA:  MOVWF  47
04EB:  MOVLW  2E
04EC:  MOVWF  4F
04ED:  CALL   2A0
04EE:  MOVF   47,W
04EF:  MOVWF  77
04F0:  MOVLW  20
04F1:  ANDWF  47,F
04F2:  MOVLW  00
04F3:  MOVLW  30
04F4:  BTFSS  47.5
04F5:  GOTO   503
04F6:  BCF    47.5
04F7:  MOVF   46,W
04F8:  BTFSS  03.2
04F9:  DECF   47,F
04FA:  MOVF   77,W
04FB:  MOVWF  47
04FC:  MOVLW  2D
04FD:  MOVWF  4F
04FE:  CALL   2A0
04FF:  MOVF   47,W
0500:  MOVWF  77
0501:  CLRF   47
0502:  MOVLW  30
0503:  ADDWF  77,F
0504:  MOVF   77,W
0505:  MOVWF  4F
0506:  CALL   2A0
0507:  BCF    03.1
0508:  MOVF   4E,W
0509:  MOVWF  52
050A:  MOVF   4D,W
050B:  MOVWF  51
050C:  MOVF   4C,W
050D:  MOVWF  50
050E:  MOVF   4B,W
050F:  MOVWF  4F
0510:  CLRF   56
0511:  CLRF   55
0512:  CLRF   54
0513:  MOVLW  0A
0514:  MOVWF  53
0515:  CALL   40F
0516:  MOVF   7A,W
0517:  MOVWF  4E
0518:  MOVF   79,W
0519:  MOVWF  4D
051A:  MOVF   78,W
051B:  MOVWF  4C
051C:  MOVF   77,W
051D:  MOVWF  4B
051E:  DECFSZ 49,F
051F:  GOTO   4A9
0520:  RETURN
0521:  MOVF   46,W
0522:  BTFSC  03.2
0523:  GOTO   5E6
0524:  MOVWF  52
0525:  MOVF   4A,W
0526:  BTFSC  03.2
0527:  GOTO   5E6
0528:  SUBWF  52,F
0529:  BTFSS  03.0
052A:  GOTO   530
052B:  MOVLW  7F
052C:  ADDWF  52,F
052D:  BTFSC  03.0
052E:  GOTO   5E6
052F:  GOTO   536
0530:  MOVLW  81
0531:  SUBWF  52,F
0532:  BTFSS  03.0
0533:  GOTO   5E6
0534:  BTFSC  03.2
0535:  GOTO   5E6
0536:  MOVF   52,W
0537:  MOVWF  77
0538:  CLRF   78
0539:  CLRF   79
053A:  CLRF   7A
053B:  CLRF   51
053C:  MOVF   47,W
053D:  MOVWF  50
053E:  BSF    50.7
053F:  MOVF   48,W
0540:  MOVWF  4F
0541:  MOVF   49,W
0542:  MOVWF  4E
0543:  MOVLW  19
0544:  MOVWF  52
0545:  MOVF   4D,W
0546:  SUBWF  4E,F
0547:  BTFSC  03.0
0548:  GOTO   559
0549:  MOVLW  01
054A:  SUBWF  4F,F
054B:  BTFSC  03.0
054C:  GOTO   559
054D:  SUBWF  50,F
054E:  BTFSC  03.0
054F:  GOTO   559
0550:  SUBWF  51,F
0551:  BTFSC  03.0
0552:  GOTO   559
0553:  INCF   51,F
0554:  INCF   50,F
0555:  INCF   4F,F
0556:  MOVF   4D,W
0557:  ADDWF  4E,F
0558:  GOTO   58B
0559:  MOVF   4C,W
055A:  SUBWF  4F,F
055B:  BTFSC  03.0
055C:  GOTO   574
055D:  MOVLW  01
055E:  SUBWF  50,F
055F:  BTFSC  03.0
0560:  GOTO   574
0561:  SUBWF  51,F
0562:  BTFSC  03.0
0563:  GOTO   574
0564:  INCF   51,F
0565:  INCF   50,F
0566:  MOVF   4C,W
0567:  ADDWF  4F,F
0568:  MOVF   4D,W
0569:  ADDWF  4E,F
056A:  BTFSS  03.0
056B:  GOTO   58B
056C:  INCF   4F,F
056D:  BTFSS  03.2
056E:  GOTO   58B
056F:  INCF   50,F
0570:  BTFSS  03.2
0571:  GOTO   58B
0572:  INCF   51,F
0573:  GOTO   58B
0574:  MOVF   4B,W
0575:  IORLW  80
0576:  SUBWF  50,F
0577:  BTFSC  03.0
0578:  GOTO   58A
0579:  MOVLW  01
057A:  SUBWF  51,F
057B:  BTFSC  03.0
057C:  GOTO   58A
057D:  INCF   51,F
057E:  MOVF   4B,W
057F:  IORLW  80
0580:  ADDWF  50,F
0581:  MOVF   4C,W
0582:  ADDWF  4F,F
0583:  BTFSS  03.0
0584:  GOTO   568
0585:  INCF   50,F
0586:  BTFSS  03.2
0587:  GOTO   568
0588:  INCF   51,F
0589:  GOTO   568
058A:  BSF    7A.0
058B:  DECFSZ 52,F
058C:  GOTO   58E
058D:  GOTO   599
058E:  BCF    03.0
058F:  RLF    4E,F
0590:  RLF    4F,F
0591:  RLF    50,F
0592:  RLF    51,F
0593:  BCF    03.0
0594:  RLF    7A,F
0595:  RLF    79,F
0596:  RLF    78,F
0597:  RLF    53,F
0598:  GOTO   545
0599:  BTFSS  53.0
059A:  GOTO   5A1
059B:  BCF    03.0
059C:  RRF    78,F
059D:  RRF    79,F
059E:  RRF    7A,F
059F:  RRF    53,F
05A0:  GOTO   5A4
05A1:  DECF   77,F
05A2:  BTFSC  03.2
05A3:  GOTO   5E6
05A4:  BTFSC  53.7
05A5:  GOTO   5CD
05A6:  BCF    03.0
05A7:  RLF    4E,F
05A8:  RLF    4F,F
05A9:  RLF    50,F
05AA:  RLF    51,F
05AB:  MOVF   4D,W
05AC:  SUBWF  4E,F
05AD:  BTFSC  03.0
05AE:  GOTO   5B9
05AF:  MOVLW  01
05B0:  SUBWF  4F,F
05B1:  BTFSC  03.0
05B2:  GOTO   5B9
05B3:  SUBWF  50,F
05B4:  BTFSC  03.0
05B5:  GOTO   5B9
05B6:  SUBWF  51,F
05B7:  BTFSS  03.0
05B8:  GOTO   5DC
05B9:  MOVF   4C,W
05BA:  SUBWF  4F,F
05BB:  BTFSC  03.0
05BC:  GOTO   5C4
05BD:  MOVLW  01
05BE:  SUBWF  50,F
05BF:  BTFSC  03.0
05C0:  GOTO   5C4
05C1:  SUBWF  51,F
05C2:  BTFSS  03.0
05C3:  GOTO   5DC
05C4:  MOVF   4B,W
05C5:  IORLW  80
05C6:  SUBWF  50,F
05C7:  BTFSC  03.0
05C8:  GOTO   5CD
05C9:  MOVLW  01
05CA:  SUBWF  51,F
05CB:  BTFSS  03.0
05CC:  GOTO   5DC
05CD:  INCF   7A,F
05CE:  BTFSS  03.2
05CF:  GOTO   5DC
05D0:  INCF   79,F
05D1:  BTFSS  03.2
05D2:  GOTO   5DC
05D3:  INCF   78,F
05D4:  BTFSS  03.2
05D5:  GOTO   5DC
05D6:  INCF   77,F
05D7:  BTFSC  03.2
05D8:  GOTO   5E6
05D9:  RRF    78,F
05DA:  RRF    79,F
05DB:  RRF    7A,F
05DC:  MOVF   47,W
05DD:  MOVWF  52
05DE:  MOVF   4B,W
05DF:  XORWF  52,F
05E0:  BTFSS  52.7
05E1:  GOTO   5E4
05E2:  BSF    78.7
05E3:  GOTO   5EA
05E4:  BCF    78.7
05E5:  GOTO   5EA
05E6:  CLRF   77
05E7:  CLRF   78
05E8:  CLRF   79
05E9:  CLRF   7A
05EA:  RETURN
05EB:  MOVF   04,W
05EC:  MOVWF  47
05ED:  MOVF   46,W
05EE:  MOVWF  49
05EF:  BTFSC  03.2
05F0:  GOTO   60A
05F1:  MOVF   45,W
05F2:  MOVWF  52
05F3:  MOVF   44,W
05F4:  MOVWF  51
05F5:  MOVF   43,W
05F6:  MOVWF  50
05F7:  MOVF   42,W
05F8:  MOVWF  4F
05F9:  CLRF   56
05FA:  CLRF   55
05FB:  MOVLW  20
05FC:  MOVWF  54
05FD:  MOVLW  82
05FE:  MOVWF  53
05FF:  CALL   37B
0600:  MOVF   7A,W
0601:  MOVWF  45
0602:  MOVF   79,W
0603:  MOVWF  44
0604:  MOVF   78,W
0605:  MOVWF  43
0606:  MOVF   77,W
0607:  MOVWF  42
0608:  DECFSZ 49,F
0609:  GOTO   5F1
060A:  MOVF   45,W
060B:  MOVWF  52
060C:  MOVF   44,W
060D:  MOVWF  51
060E:  MOVF   43,W
060F:  MOVWF  50
0610:  MOVF   42,W
0611:  MOVWF  4F
0612:  CALL   3F0
0613:  MOVF   7A,W
0614:  MOVWF  45
0615:  MOVF   79,W
0616:  MOVWF  44
0617:  MOVF   78,W
0618:  MOVWF  43
0619:  MOVF   77,W
061A:  MOVWF  42
061B:  BTFSS  45.7
061C:  GOTO   62A
061D:  DECF   47,F
061E:  BSF    47.5
061F:  COMF   42,F
0620:  COMF   43,F
0621:  COMF   44,F
0622:  COMF   45,F
0623:  INCF   42,F
0624:  BTFSC  03.2
0625:  INCF   43,F
0626:  BTFSC  03.2
0627:  INCF   44,F
0628:  BTFSC  03.2
0629:  INCF   45,F
062A:  MOVLW  3B
062B:  MOVWF  4E
062C:  MOVLW  9A
062D:  MOVWF  4D
062E:  MOVLW  CA
062F:  MOVWF  4C
0630:  CLRF   4B
0631:  MOVLW  0A
0632:  MOVWF  49
0633:  MOVF   46,W
0634:  BTFSC  03.2
0635:  INCF   47,F
0636:  BSF    03.1
0637:  MOVLW  42
0638:  MOVWF  04
0639:  BCF    03.7
063A:  MOVF   45,W
063B:  MOVWF  52
063C:  MOVF   44,W
063D:  MOVWF  51
063E:  MOVF   43,W
063F:  MOVWF  50
0640:  MOVF   42,W
0641:  MOVWF  4F
0642:  MOVF   4E,W
0643:  MOVWF  56
0644:  MOVF   4D,W
0645:  MOVWF  55
0646:  MOVF   4C,W
0647:  MOVWF  54
0648:  MOVF   4B,W
0649:  MOVWF  53
064A:  CALL   40F
064B:  MOVF   78,W
064C:  MOVF   77,F
064D:  BTFSS  03.2
064E:  GOTO   662
064F:  INCF   46,W
0650:  SUBWF  49,W
0651:  BTFSC  03.2
0652:  GOTO   662
0653:  MOVF   47,W
0654:  BTFSC  03.2
0655:  GOTO   664
0656:  ANDLW  0F
0657:  SUBWF  49,W
0658:  BTFSC  03.2
0659:  GOTO   65C
065A:  BTFSC  03.0
065B:  GOTO   698
065C:  BTFSC  47.7
065D:  GOTO   698
065E:  BTFSC  47.6
065F:  GOTO   664
0660:  MOVLW  20
0661:  GOTO   693
0662:  MOVLW  20
0663:  ANDWF  47,F
0664:  BTFSS  47.5
0665:  GOTO   673
0666:  BCF    47.5
0667:  MOVF   46,W
0668:  BTFSS  03.2
0669:  DECF   47,F
066A:  MOVF   77,W
066B:  MOVWF  47
066C:  MOVLW  2D
066D:  BTFSS  0C.4
066E:  GOTO   66D
066F:  MOVWF  19
0670:  MOVF   47,W
0671:  MOVWF  77
0672:  CLRF   47
0673:  MOVF   46,W
0674:  SUBWF  49,W
0675:  BTFSS  03.2
0676:  GOTO   682
0677:  MOVF   77,W
0678:  MOVWF  47
0679:  MOVLW  2E
067A:  BTFSS  0C.4
067B:  GOTO   67A
067C:  MOVWF  19
067D:  MOVF   47,W
067E:  MOVWF  77
067F:  MOVLW  20
0680:  ANDWF  47,F
0681:  MOVLW  00
0682:  MOVLW  30
0683:  BTFSS  47.5
0684:  GOTO   693
0685:  BCF    47.5
0686:  MOVF   46,W
0687:  BTFSS  03.2
0688:  DECF   47,F
0689:  MOVF   77,W
068A:  MOVWF  47
068B:  MOVLW  2D
068C:  BTFSS  0C.4
068D:  GOTO   68C
068E:  MOVWF  19
068F:  MOVF   47,W
0690:  MOVWF  77
0691:  CLRF   47
0692:  MOVLW  30
0693:  ADDWF  77,F
0694:  MOVF   77,W
0695:  BTFSS  0C.4
0696:  GOTO   695
0697:  MOVWF  19
0698:  BCF    03.1
0699:  MOVF   4E,W
069A:  MOVWF  52
069B:  MOVF   4D,W
069C:  MOVWF  51
069D:  MOVF   4C,W
069E:  MOVWF  50
069F:  MOVF   4B,W
06A0:  MOVWF  4F
06A1:  CLRF   56
06A2:  CLRF   55
06A3:  CLRF   54
06A4:  MOVLW  0A
06A5:  MOVWF  53
06A6:  CALL   40F
06A7:  MOVF   7A,W
06A8:  MOVWF  4E
06A9:  MOVF   79,W
06AA:  MOVWF  4D
06AB:  MOVF   78,W
06AC:  MOVWF  4C
06AD:  MOVF   77,W
06AE:  MOVWF  4B
06AF:  DECFSZ 49,F
06B0:  GOTO   636
06B1:  BSF    0A.3
06B2:  BCF    0A.4
06B3:  GOTO   0F9 (RETURN)
06B4:  MOVLW  8E
06B5:  MOVWF  77
06B6:  MOVF   42,W
06B7:  SUBWF  77,F
06B8:  MOVF   43,W
06B9:  MOVWF  79
06BA:  MOVF   44,W
06BB:  MOVWF  78
06BC:  BSF    79.7
06BD:  MOVF   77,F
06BE:  BTFSC  03.2
06BF:  GOTO   6CB
06C0:  BCF    03.0
06C1:  MOVF   79,F
06C2:  BTFSS  03.2
06C3:  GOTO   6C7
06C4:  MOVF   78,F
06C5:  BTFSC  03.2
06C6:  GOTO   6CB
06C7:  RRF    79,F
06C8:  RRF    78,F
06C9:  DECFSZ 77,F
06CA:  GOTO   6C0
06CB:  BTFSS  43.7
06CC:  GOTO   6D2
06CD:  COMF   78,F
06CE:  COMF   79,F
06CF:  INCF   78,F
06D0:  BTFSC  03.2
06D1:  INCF   79,F
06D2:  BSF    0A.3
06D3:  BCF    0A.4
06D4:  GOTO   17B (RETURN)
.................... 
.................... #list
.................... 
.................... #DEVICE ADC=10
.................... #USE delay(crystal=4Mhz)
*
0149:  MOVLW  50
014A:  MOVWF  04
014B:  BCF    03.7
014C:  MOVF   00,W
014D:  BTFSC  03.2
014E:  GOTO   15D
014F:  MOVLW  01
0150:  MOVWF  78
0151:  CLRF   77
0152:  DECFSZ 77,F
0153:  GOTO   152
0154:  DECFSZ 78,F
0155:  GOTO   151
0156:  MOVLW  4A
0157:  MOVWF  77
0158:  DECFSZ 77,F
0159:  GOTO   158
015A:  GOTO   15B
015B:  DECFSZ 00,F
015C:  GOTO   14F
015D:  RETURN
.................... #fuses HS,NOWDT,NOPROTECT,PUT,NOLVP,NOBROWNOUT
.................... #use RS232(BAUD=9600, BITS=8, PARITY=N, XMIT=PIN_C6, RCV=PIN_C7)
.................... #include <stdio.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDIO
.................... #define _STDIO
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n)
.................... {
....................   unsigned char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int8 memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1*/
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n)
.................... {
....................   unsigned char *s;
....................   unsigned int8 n1;
....................   n1=n;
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    unsigned char uc;
....................    unsigned char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2)
.................... {
....................    unsigned char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2)
.................... {
....................    unsigned char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c)
.................... {
....................    unsigned char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2)
.................... {
....................    unsigned char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2)
.................... {
....................    unsigned char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2)
.................... {
....................    unsigned char *beg, *end;
....................    static char *save;
*
0820:  BCF    03.5
0821:  CLRF   2C
0822:  CLRF   2D
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................    {
....................       *save = ' ';
....................       return(0);
....................    }
....................    end = strpbrk(beg, s2);
....................    if (*end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................    }
....................    save = end;
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... unsigned char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... unsigned int8 strlen(unsigned char *s)
.................... {
....................    unsigned char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... unsigned char *strlwr(unsigned char *s)
.................... {
....................    unsigned char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... unsigned char *strupr(unsigned char *s)
.................... {
....................    unsigned char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... #ifndef getc
.................... #define getc getch
.................... #define getchar getch
.................... #define puts(s) {printf(s); putchar(13); putchar(10);}
.................... #define putc putchar
.................... #endif
.................... /* maps error number to an error message. Writes a sequence of characters to
.................... stderr stream thus: if s is not null then string pointed to by s follwed by
.................... a colon (:) and a space and the appropriate error message returned by strerror
.................... function with argument errno
.................... 
.................... Returns: no value
.................... */
.................... 
.................... #ifdef _ERRNO
.................... void perror(char *s)
.................... {
....................   if(s)
....................   fprintf(STDERR,"%s: ",s);
....................   fprintf(STDERR,"%s\r\n",strerror(errno));
.................... }
.................... #endif
.................... #endif
.................... 
.................... 
.................... #USE STANDARD_IO(B)
.................... #USE STANDARD_IO(C)
.................... #USE STANDARD_IO(D)
.................... 
.................... #DEFINE M1 PIN_E2
.................... 
.................... #define LCD_DATA_PORT   0X07 //Utilizar LCD en puerto C
.................... #define LCD_ENABLE_PIN  PIN_C5
.................... #define LCD_RS_PIN      PIN_C3
.................... #define LCD_RW_PIN      PIN_C4
.................... #define LCD_DATA4       PIN_D4
.................... #define LCD_DATA5       PIN_D5
.................... #define LCD_DATA6       PIN_D6
.................... #define LCD_DATA7       PIN_D7
.................... 
.................... #include <lcd.c> 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ////                             LCD.C                                     ////
.................... ////                 Driver for common LCD modules                         ////
.................... ////                                                                       ////
.................... ////  lcd_init()   Must be called before any other function.               ////
.................... ////                                                                       ////
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         ////
.................... ////                 \a  Set cursor position to upper left                 ////
.................... ////                 \f  Clear display, set cursor to upper left           ////
.................... ////                 \n  Go to start of second line                        ////
.................... ////                 \b  Move back one position                            ////
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     ////
.................... ////              will erase all remanining characters on the current      ////
.................... ////              line, and move the cursor to the beginning of the next   ////
.................... ////              line.                                                    ////
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     ////
.................... ////              will move the cursor to the start of the current         ////
.................... ////              line.                                                    ////
.................... ////                                                                       ////
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        ////
.................... ////                                                                       ////
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             ////
.................... ////                                                                       ////
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         ////
.................... ////              (on=FALSE).                                              ////
.................... ////                                                                       ////
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   ////
.................... ////                                                                       ////
.................... ////                                                                       ////
.................... ////  CONFIGURATION                                                        ////
.................... ////  The LCD can be configured in one of two ways: a.) port access or     ////
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     ////
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     ////
.................... ////  connected to sequential pins on the GPIO.  Pin access                ////
.................... ////  has no requirements, all 7 bits of the control interface can         ////
.................... ////  can be connected to any GPIO using several ports.                    ////
.................... ////                                                                       ////
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     ////
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    ////
.................... ////  of this file to configure the pin order.  If you are using a         ////
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  ////
.................... ////  be defined.                                                          ////
.................... ////                                                                       ////
.................... ////  Example of port access:                                              ////
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         ////
.................... ////                                                                       ////
.................... ////  To use pin access, the following pins must be defined:               ////
.................... ////     LCD_ENABLE_PIN                                                    ////
.................... ////     LCD_RS_PIN                                                        ////
.................... ////     LCD_RW_PIN                                                        ////
.................... ////     LCD_DATA4                                                         ////
.................... ////     LCD_DATA5                                                         ////
.................... ////     LCD_DATA6                                                         ////
.................... ////     LCD_DATA7                                                         ////
.................... ////                                                                       ////
.................... ////  Example of pin access:                                               ////
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    ////
.................... ////     #define LCD_RS_PIN      PIN_E1                                    ////
.................... ////     #define LCD_RW_PIN      PIN_E2                                    ////
.................... ////     #define LCD_DATA4       PIN_D4                                    ////
.................... ////     #define LCD_DATA5       PIN_D5                                    ////
.................... ////     #define LCD_DATA6       PIN_D6                                    ////
.................... ////     #define LCD_DATA7       PIN_D7                                    ////
.................... ////                                                                       ////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __LCD_C__
.................... #define __LCD_C__
.................... 
.................... // define the pinout.
.................... // only required if port access is being used.
.................... typedef struct  
.................... {                            // This structure is overlayed
....................    int1 enable;           // on to an I/O port to gain
....................    int1 rs;               // access to the LCD pins.
....................    int1 rw;               // The bits are allocated from
....................    int1 unused;           // low order up.  ENABLE will
....................    unsigned int     data : 4;         // be LSB pin of that port.
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT.
....................    unsigned int    reserved: 8;
....................   #endif
.................... } LCD_PIN_MAP;
.................... 
.................... // this is to improve compatability with previous LCD drivers that accepted
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B.
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE))
....................  #define LCD_DATA_PORT getenv("SFR:PORTB")
.................... #endif
.................... 
.................... #if defined(__PCB__)
....................    // these definitions only need to be modified for baseline PICs.
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions.
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0};
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF};
.................... #endif
.................... 
.................... ////////////////////// END CONFIGURATION ///////////////////////////////////
.................... 
.................... #ifndef LCD_ENABLE_PIN
....................    #define lcd_output_enable(x) lcdlat.enable=x
....................    #define lcd_enable_tris()   lcdtris.enable=0
.................... #else
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x)
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN)
.................... #endif
.................... 
.................... #ifndef LCD_RS_PIN
....................    #define lcd_output_rs(x) lcdlat.rs=x
....................    #define lcd_rs_tris()   lcdtris.rs=0
.................... #else
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x)
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN)
.................... #endif
.................... 
.................... #ifndef LCD_RW_PIN
....................    #define lcd_output_rw(x) lcdlat.rw=x
....................    #define lcd_rw_tris()   lcdtris.rw=0
.................... #else
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x)
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN)
.................... #endif
.................... 
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4,
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver
.................... // compatible with any code written for the original library
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7))
....................    #define  LCD_DATA4    LCD_DATA0
....................    #define  LCD_DATA5    LCD_DATA1
....................    #define  LCD_DATA6    LCD_DATA2
....................    #define  LCD_DATA7    LCD_DATA3
.................... #endif
.................... 
.................... #ifndef LCD_DATA4
.................... #ifndef LCD_DATA_PORT
....................    #if defined(__PCB__)
....................       #define LCD_DATA_PORT      0x06     //portb
....................       #define set_tris_lcd(x)   set_tris_b(x)
....................    #else
....................      #if defined(PIN_D0)
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd
....................      #else
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb
....................      #endif
....................    #endif   
.................... #endif
.................... 
.................... #if defined(__PCB__)
....................    LCD_PIN_MAP lcd, lcdlat;
....................    #byte lcd = LCD_DATA_PORT
....................    #byte lcdlat = LCD_DATA_PORT
.................... #elif defined(__PCM__)
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris;
....................    #byte lcd = LCD_DATA_PORT
....................    #byte lcdlat = LCD_DATA_PORT
....................    #byte lcdtris = LCD_DATA_PORT+0x80
.................... #elif defined(__PCH__)
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris;
....................    #byte lcd = LCD_DATA_PORT
....................    #byte lcdlat = LCD_DATA_PORT+9
....................    #byte lcdtris = LCD_DATA_PORT+0x12
.................... #elif defined(__PCD__)
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris;
....................    #word lcd = LCD_DATA_PORT
....................    #word lcdlat = LCD_DATA_PORT+2
....................    #word lcdtris = LCD_DATA_PORT-0x02
.................... #endif
.................... #endif   //LCD_DATA4 not defined
.................... 
.................... #ifndef LCD_TYPE
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines
.................... #endif
.................... 
.................... #ifndef LCD_LINE_TWO
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line
.................... #endif
.................... 
.................... #ifndef LCD_LINE_LENGTH
....................    #define LCD_LINE_LENGTH 20
.................... #endif
.................... 
.................... unsigned int8 lcd_read_nibble(void);
.................... 
.................... unsigned int8 lcd_read_byte(void)
.................... {
....................    unsigned int8 low,high;
.................... 
....................  #if defined(__PCB__)
....................    set_tris_lcd(LCD_INPUT_MAP);
....................  #else
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    output_float(LCD_DATA4);
*
01D2:  BSF    08.4
....................    output_float(LCD_DATA5);
01D3:  BSF    08.5
....................    output_float(LCD_DATA6);
01D4:  BSF    08.6
....................    output_float(LCD_DATA7);
01D5:  BSF    08.7
....................   #else
....................    lcdtris.data = 0xF;
....................   #endif
....................  #endif
....................         
....................    lcd_output_rw(1);
01D6:  BCF    03.5
01D7:  BSF    07.4
01D8:  BCF    2E.4
01D9:  MOVF   2E,W
01DA:  BSF    03.5
01DB:  MOVWF  07
....................    delay_cycles(1);
01DC:  NOP
....................    lcd_output_enable(1);
01DD:  BCF    03.5
01DE:  BSF    07.5
01DF:  BCF    2E.5
01E0:  MOVF   2E,W
01E1:  BSF    03.5
01E2:  MOVWF  07
....................    delay_cycles(1);
01E3:  NOP
....................    high = lcd_read_nibble();
01E4:  BCF    03.5
01E5:  CALL   18D
01E6:  MOVF   78,W
01E7:  MOVWF  57
....................       
....................    lcd_output_enable(0);
01E8:  BCF    07.5
01E9:  BCF    2E.5
01EA:  MOVF   2E,W
01EB:  BSF    03.5
01EC:  MOVWF  07
....................    delay_cycles(1);
01ED:  NOP
....................    lcd_output_enable(1);
01EE:  BCF    03.5
01EF:  BSF    07.5
01F0:  BCF    2E.5
01F1:  MOVF   2E,W
01F2:  BSF    03.5
01F3:  MOVWF  07
....................    delay_us(1);
01F4:  NOP
....................    low = lcd_read_nibble();
01F5:  BCF    03.5
01F6:  CALL   18D
01F7:  MOVF   78,W
01F8:  MOVWF  56
....................       
....................    lcd_output_enable(0);
01F9:  BCF    07.5
01FA:  BCF    2E.5
01FB:  MOVF   2E,W
01FC:  BSF    03.5
01FD:  MOVWF  07
.................... 
....................  #if defined(__PCB__)
....................    set_tris_lcd(LCD_OUTPUT_MAP);
....................  #else
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    output_drive(LCD_DATA4);
01FE:  BCF    08.4
....................    output_drive(LCD_DATA5);
01FF:  BCF    08.5
....................    output_drive(LCD_DATA6);
0200:  BCF    08.6
....................    output_drive(LCD_DATA7);
0201:  BCF    08.7
....................   #else
....................    lcdtris.data = 0x0;
....................   #endif
....................  #endif
.................... 
....................    return( (high<<4) | low);
0202:  BCF    03.5
0203:  SWAPF  57,W
0204:  MOVWF  77
0205:  MOVLW  F0
0206:  ANDWF  77,F
0207:  MOVF   77,W
0208:  IORWF  56,W
0209:  MOVWF  78
.................... }
.................... 
.................... unsigned int8 lcd_read_nibble(void)
.................... {
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
*
018D:  CLRF   58
....................    unsigned int8 n = 0x00;
.................... 
....................    /* Read the data port */
....................    n |= input(LCD_DATA4);
018E:  BSF    03.5
018F:  BSF    08.4
0190:  MOVLW  00
0191:  BCF    03.5
0192:  BTFSC  08.4
0193:  MOVLW  01
0194:  IORWF  58,F
....................    n |= input(LCD_DATA5) << 1;
0195:  BSF    03.5
0196:  BSF    08.5
0197:  MOVLW  00
0198:  BCF    03.5
0199:  BTFSC  08.5
019A:  MOVLW  01
019B:  MOVWF  77
019C:  BCF    03.0
019D:  RLF    77,F
019E:  MOVF   77,W
019F:  IORWF  58,F
....................    n |= input(LCD_DATA6) << 2;
01A0:  BSF    03.5
01A1:  BSF    08.6
01A2:  MOVLW  00
01A3:  BCF    03.5
01A4:  BTFSC  08.6
01A5:  MOVLW  01
01A6:  MOVWF  77
01A7:  RLF    77,F
01A8:  RLF    77,F
01A9:  MOVLW  FC
01AA:  ANDWF  77,F
01AB:  MOVF   77,W
01AC:  IORWF  58,F
....................    n |= input(LCD_DATA7) << 3;
01AD:  BSF    03.5
01AE:  BSF    08.7
01AF:  MOVLW  00
01B0:  BCF    03.5
01B1:  BTFSC  08.7
01B2:  MOVLW  01
01B3:  MOVWF  77
01B4:  RLF    77,F
01B5:  RLF    77,F
01B6:  RLF    77,F
01B7:  MOVLW  F8
01B8:  ANDWF  77,F
01B9:  MOVF   77,W
01BA:  IORWF  58,F
....................    
....................    return(n);
01BB:  MOVF   58,W
01BC:  MOVWF  78
....................   #else
01BD:  RETURN
....................    return(lcd.data);
....................   #endif
.................... }
.................... 
.................... void lcd_send_nibble(unsigned int8 n)
.................... {
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    /* Write to the data port */
....................    output_bit(LCD_DATA4, bit_test(n, 0));
*
015E:  BTFSC  57.0
015F:  GOTO   162
0160:  BCF    08.4
0161:  GOTO   163
0162:  BSF    08.4
0163:  BSF    03.5
0164:  BCF    08.4
....................    output_bit(LCD_DATA5, bit_test(n, 1));
0165:  BCF    03.5
0166:  BTFSC  57.1
0167:  GOTO   16A
0168:  BCF    08.5
0169:  GOTO   16B
016A:  BSF    08.5
016B:  BSF    03.5
016C:  BCF    08.5
....................    output_bit(LCD_DATA6, bit_test(n, 2));
016D:  BCF    03.5
016E:  BTFSC  57.2
016F:  GOTO   172
0170:  BCF    08.6
0171:  GOTO   173
0172:  BSF    08.6
0173:  BSF    03.5
0174:  BCF    08.6
....................    output_bit(LCD_DATA7, bit_test(n, 3));
0175:  BCF    03.5
0176:  BTFSC  57.3
0177:  GOTO   17A
0178:  BCF    08.7
0179:  GOTO   17B
017A:  BSF    08.7
017B:  BSF    03.5
017C:  BCF    08.7
....................   #else      
....................    lcdlat.data = n;
....................   #endif
....................       
....................    delay_cycles(1);
017D:  NOP
....................    lcd_output_enable(1);
017E:  BCF    03.5
017F:  BSF    07.5
0180:  BCF    2E.5
0181:  MOVF   2E,W
0182:  BSF    03.5
0183:  MOVWF  07
....................    delay_us(2);
0184:  GOTO   185
....................    lcd_output_enable(0);
0185:  BCF    03.5
0186:  BCF    07.5
0187:  BCF    2E.5
0188:  MOVF   2E,W
0189:  BSF    03.5
018A:  MOVWF  07
018B:  BCF    03.5
018C:  RETURN
.................... }
.................... 
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n)
.................... {
....................   #if defined(__PCB__)
....................    set_tris_lcd(LCD_OUTPUT_MAP);
....................   #else
....................    lcd_enable_tris();
*
01BE:  BCF    2E.5
01BF:  MOVF   2E,W
01C0:  BSF    03.5
01C1:  MOVWF  07
....................    lcd_rs_tris();
01C2:  BCF    03.5
01C3:  BCF    2E.3
01C4:  MOVF   2E,W
01C5:  BSF    03.5
01C6:  MOVWF  07
....................    lcd_rw_tris();
01C7:  BCF    03.5
01C8:  BCF    2E.4
01C9:  MOVF   2E,W
01CA:  BSF    03.5
01CB:  MOVWF  07
....................   #endif
.................... 
....................    lcd_output_rs(0);
01CC:  BCF    03.5
01CD:  BCF    07.3
01CE:  BCF    2E.3
01CF:  MOVF   2E,W
01D0:  BSF    03.5
01D1:  MOVWF  07
....................    while ( bit_test(lcd_read_byte(),7) ) ;
*
020A:  MOVF   78,W
020B:  MOVWF  56
020C:  BTFSS  56.7
020D:  GOTO   210
020E:  BSF    03.5
020F:  GOTO   1D2
....................    lcd_output_rs(address);
0210:  MOVF   54,F
0211:  BTFSS  03.2
0212:  GOTO   215
0213:  BCF    07.3
0214:  GOTO   216
0215:  BSF    07.3
0216:  BCF    2E.3
0217:  MOVF   2E,W
0218:  BSF    03.5
0219:  MOVWF  07
....................    delay_cycles(1);
021A:  NOP
....................    lcd_output_rw(0);
021B:  BCF    03.5
021C:  BCF    07.4
021D:  BCF    2E.4
021E:  MOVF   2E,W
021F:  BSF    03.5
0220:  MOVWF  07
....................    delay_cycles(1);
0221:  NOP
....................    lcd_output_enable(0);
0222:  BCF    03.5
0223:  BCF    07.5
0224:  BCF    2E.5
0225:  MOVF   2E,W
0226:  BSF    03.5
0227:  MOVWF  07
....................    lcd_send_nibble(n >> 4);
0228:  BCF    03.5
0229:  SWAPF  55,W
022A:  MOVWF  56
022B:  MOVLW  0F
022C:  ANDWF  56,F
022D:  MOVF   56,W
022E:  MOVWF  57
022F:  CALL   15E
....................    lcd_send_nibble(n & 0xf);
0230:  MOVF   55,W
0231:  ANDLW  0F
0232:  MOVWF  56
0233:  MOVWF  57
0234:  CALL   15E
0235:  RETURN
.................... }
.................... 
.................... #if defined(LCD_EXTENDED_NEWLINE)
.................... unsigned int8 g_LcdX, g_LcdY;
.................... #endif
.................... 
.................... void lcd_init(void) 
.................... {
....................    unsigned int8 i;
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6};
0236:  MOVLW  28
0237:  MOVWF  43
0238:  MOVLW  0C
0239:  MOVWF  44
023A:  MOVLW  01
023B:  MOVWF  45
023C:  MOVLW  06
023D:  MOVWF  46
....................                              // These bytes need to be sent to the LCD
....................                              // to start it up.
....................    
.................... 
....................    lcd_output_enable(0);
023E:  BCF    07.5
023F:  BCF    2E.5
0240:  MOVF   2E,W
0241:  BSF    03.5
0242:  MOVWF  07
....................    lcd_output_rs(0);
0243:  BCF    03.5
0244:  BCF    07.3
0245:  BCF    2E.3
0246:  MOVF   2E,W
0247:  BSF    03.5
0248:  MOVWF  07
....................    lcd_output_rw(0);
0249:  BCF    03.5
024A:  BCF    07.4
024B:  BCF    2E.4
024C:  MOVF   2E,W
024D:  BSF    03.5
024E:  MOVWF  07
.................... 
....................  #if defined(__PCB__)
....................    set_tris_lcd(LCD_OUTPUT_MAP);
....................  #else
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    output_drive(LCD_DATA4);
024F:  BCF    08.4
....................    output_drive(LCD_DATA5);
0250:  BCF    08.5
....................    output_drive(LCD_DATA6);
0251:  BCF    08.6
....................    output_drive(LCD_DATA7);
0252:  BCF    08.7
....................   #else
....................    lcdtris.data = 0x0;
....................   #endif
....................    lcd_enable_tris();
0253:  BCF    03.5
0254:  BCF    2E.5
0255:  MOVF   2E,W
0256:  BSF    03.5
0257:  MOVWF  07
....................    lcd_rs_tris();
0258:  BCF    03.5
0259:  BCF    2E.3
025A:  MOVF   2E,W
025B:  BSF    03.5
025C:  MOVWF  07
....................    lcd_rw_tris();
025D:  BCF    03.5
025E:  BCF    2E.4
025F:  MOVF   2E,W
0260:  BSF    03.5
0261:  MOVWF  07
....................  #endif
....................     
....................    delay_ms(15);
0262:  MOVLW  0F
0263:  BCF    03.5
0264:  MOVWF  50
0265:  CALL   149
....................    for(i=1;i<=3;++i)
0266:  MOVLW  01
0267:  MOVWF  42
0268:  MOVF   42,W
0269:  SUBLW  03
026A:  BTFSS  03.0
026B:  GOTO   274
....................    {
....................        lcd_send_nibble(3);
026C:  MOVLW  03
026D:  MOVWF  57
026E:  CALL   15E
....................        delay_ms(5);
026F:  MOVLW  05
0270:  MOVWF  50
0271:  CALL   149
0272:  INCF   42,F
0273:  GOTO   268
....................    }
....................    
....................    lcd_send_nibble(2);
0274:  MOVLW  02
0275:  MOVWF  57
0276:  CALL   15E
....................    delay_ms(5);
0277:  MOVLW  05
0278:  MOVWF  50
0279:  CALL   149
....................    for(i=0;i<=3;++i)
027A:  CLRF   42
027B:  MOVF   42,W
027C:  SUBLW  03
027D:  BTFSS  03.0
027E:  GOTO   28B
....................       lcd_send_byte(0,LCD_INIT_STRING[i]);
027F:  MOVLW  43
0280:  ADDWF  42,W
0281:  MOVWF  04
0282:  BCF    03.7
0283:  MOVF   00,W
0284:  MOVWF  47
0285:  CLRF   54
0286:  MOVF   47,W
0287:  MOVWF  55
0288:  CALL   1BE
.................... 
....................   #if defined(LCD_EXTENDED_NEWLINE)
0289:  INCF   42,F
028A:  GOTO   27B
028B:  BSF    0A.3
028C:  BCF    0A.4
028D:  GOTO   028 (RETURN)
....................    g_LcdX = 0;
....................    g_LcdY = 0;
....................   #endif
.................... }
.................... 
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y)
.................... {
....................    unsigned int8 address;
....................    
....................    if(y!=1)
028E:  DECFSZ 51,W
028F:  GOTO   291
0290:  GOTO   294
....................       address=LCD_LINE_TWO;
0291:  MOVLW  40
0292:  MOVWF  52
0293:  GOTO   295
....................    else
....................       address=0;
0294:  CLRF   52
....................      
....................    address+=x-1;
0295:  MOVLW  01
0296:  SUBWF  50,W
0297:  ADDWF  52,F
....................    lcd_send_byte(0,0x80|address);
0298:  MOVF   52,W
0299:  IORLW  80
029A:  MOVWF  53
029B:  CLRF   54
029C:  MOVF   53,W
029D:  MOVWF  55
029E:  CALL   1BE
.................... 
....................   #if defined(LCD_EXTENDED_NEWLINE)
029F:  RETURN
....................    g_LcdX = x - 1;
....................    g_LcdY = y - 1;
....................   #endif
.................... }
.................... 
.................... void lcd_putc(char c)
.................... {
....................    switch (c)
02A0:  MOVF   4F,W
02A1:  XORLW  07
02A2:  BTFSC  03.2
02A3:  GOTO   2AE
02A4:  XORLW  0B
02A5:  BTFSC  03.2
02A6:  GOTO   2B3
02A7:  XORLW  06
02A8:  BTFSC  03.2
02A9:  GOTO   2BB
02AA:  XORLW  02
02AB:  BTFSC  03.2
02AC:  GOTO   2C1
02AD:  GOTO   2C6
....................    {
....................       case '\a'   :  lcd_gotoxy(1,1);     break;
02AE:  MOVLW  01
02AF:  MOVWF  50
02B0:  MOVWF  51
02B1:  CALL   28E
02B2:  GOTO   2CB
.................... 
....................       case '\f'   :  lcd_send_byte(0,1);
02B3:  CLRF   54
02B4:  MOVLW  01
02B5:  MOVWF  55
02B6:  CALL   1BE
....................                      delay_ms(2);
02B7:  MOVLW  02
02B8:  MOVWF  50
02B9:  CALL   149
....................                     #if defined(LCD_EXTENDED_NEWLINE)
....................                      g_LcdX = 0;
....................                      g_LcdY = 0;
....................                     #endif
....................                      break;
02BA:  GOTO   2CB
.................... 
....................      #if defined(LCD_EXTENDED_NEWLINE)
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break;
....................       case '\n'   :
....................          while (g_LcdX++ < LCD_LINE_LENGTH)
....................          {
....................             lcd_send_byte(1, ' ');
....................          }
....................          lcd_gotoxy(1, g_LcdY+2);
....................          break;
....................      #else
....................       case '\n'   : lcd_gotoxy(1,2);        break;
02BB:  MOVLW  01
02BC:  MOVWF  50
02BD:  MOVLW  02
02BE:  MOVWF  51
02BF:  CALL   28E
02C0:  GOTO   2CB
....................      #endif
....................      
....................       case '\b'   : lcd_send_byte(0,0x10);  break;
02C1:  CLRF   54
02C2:  MOVLW  10
02C3:  MOVWF  55
02C4:  CALL   1BE
02C5:  GOTO   2CB
....................      
....................      #if defined(LCD_EXTENDED_NEWLINE)
....................       default     : 
....................          if (g_LcdX < LCD_LINE_LENGTH)
....................          {
....................             lcd_send_byte(1, c);
....................             g_LcdX++;
....................          }
....................          break;
....................      #else
....................       default     : lcd_send_byte(1,c);     break;
02C6:  MOVLW  01
02C7:  MOVWF  54
02C8:  MOVF   4F,W
02C9:  MOVWF  55
02CA:  CALL   1BE
....................      #endif
....................    }
02CB:  RETURN
.................... }
....................  
.................... char lcd_getc(unsigned int8 x, unsigned int8 y)
.................... {
....................    char value;
.................... 
....................    lcd_gotoxy(x,y);
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low
....................    lcd_output_rs(1);
....................    value = lcd_read_byte();
....................    lcd_output_rs(0);
....................    
....................    return(value);
.................... }
.................... 
.................... // write a custom character to the ram
.................... // which is 0-7 and specifies which character array we are modifying.
.................... // ptr points to an array of 8 bytes, where each byte is the next row of
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and
.................... //    usually you will want to leave this byte 0x00.
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr)
.................... {
....................    unsigned int i;
.................... 
....................    which <<= 3;
....................    which &= 0x38;
.................... 
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address
.................... 
....................    for(i=0; i<8; i++)
....................    {
....................       lcd_send_byte(1, *ptr++);
....................    }
....................   
....................    #if defined(LCD_EXTENDED_NEWLINE)
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address
....................    #endif
.................... }
.................... 
.................... void lcd_cursor_on(int1 on)
.................... {
....................    if (on)
....................    {
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON
....................    }
....................    else
....................    {
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF
....................    }
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... short High = 0;
.................... 
.................... int16 T_HIGH;
.................... int16 T_LOW;
.................... 
.................... char dato_rx;
.................... 
.................... int16 contador=0;
.................... double porcentaje;
.................... float RPM=0;
.................... int dientes=12;
.................... 
.................... #INT_EXT
.................... void ext_isr(){
....................    contador++;
*
005F:  INCF   35,F
0060:  BTFSC  03.2
0061:  INCF   36,F
.................... }
.................... 
0062:  BCF    0B.1
0063:  BCF    0A.3
0064:  BCF    0A.4
0065:  GOTO   035
.................... #INT_TIMER0
.................... void ext_isr2(){
....................       if(porcentaje >= 100){
*
00A5:  CLRF   5F
00A6:  CLRF   5E
00A7:  MOVLW  48
00A8:  MOVWF  5D
00A9:  MOVLW  85
00AA:  MOVWF  5C
00AB:  MOVF   3A,W
00AC:  MOVWF  63
00AD:  MOVF   39,W
00AE:  MOVWF  62
00AF:  MOVF   38,W
00B0:  MOVWF  61
00B1:  MOVF   37,W
00B2:  MOVWF  60
00B3:  CALL   066
00B4:  BTFSC  03.0
00B5:  GOTO   0B8
00B6:  BTFSS  03.2
00B7:  GOTO   0BF
....................          set_timer0(T_HIGH);
00B8:  MOVF   30,W
00B9:  MOVWF  01
....................          output_high(M1);
00BA:  BSF    03.5
00BB:  BCF    09.2
00BC:  BCF    03.5
00BD:  BSF    09.2
....................       return;
00BE:  GOTO   0E6
....................       }
....................       if(porcentaje == 0){
00BF:  MOVF   3A,W
00C0:  MOVWF  5F
00C1:  MOVF   39,W
00C2:  MOVWF  5E
00C3:  MOVF   38,W
00C4:  MOVWF  5D
00C5:  MOVF   37,W
00C6:  MOVWF  5C
00C7:  CLRF   63
00C8:  CLRF   62
00C9:  CLRF   61
00CA:  CLRF   60
00CB:  CALL   066
00CC:  BTFSS  03.2
00CD:  GOTO   0D5
....................          set_timer0(T_HIGH);
00CE:  MOVF   30,W
00CF:  MOVWF  01
....................          output_low(M1);
00D0:  BSF    03.5
00D1:  BCF    09.2
00D2:  BCF    03.5
00D3:  BCF    09.2
....................       return;
00D4:  GOTO   0E6
....................       }
....................       if(High){
00D5:  BTFSS  2F.0
00D6:  GOTO   0DE
....................        set_timer0(T_HIGH); 
00D7:  MOVF   30,W
00D8:  MOVWF  01
....................        output_high(M1);
00D9:  BSF    03.5
00DA:  BCF    09.2
00DB:  BCF    03.5
00DC:  BSF    09.2
....................      }else{
00DD:  GOTO   0E4
....................        set_timer0(T_LOW);
00DE:  MOVF   32,W
00DF:  MOVWF  01
....................        output_low(M1);
00E0:  BSF    03.5
00E1:  BCF    09.2
00E2:  BCF    03.5
00E3:  BCF    09.2
....................      }
....................    High++;
00E4:  MOVLW  01
00E5:  XORWF  2F,F
.................... }
.................... 
00E6:  BCF    0B.2
00E7:  BCF    0A.3
00E8:  BCF    0A.4
00E9:  GOTO   035
.................... #INT_RDA
.................... void interrupcion_RDA(){
....................  
....................    dato_rx = getc();
*
0107:  BTFSS  0C.5
0108:  GOTO   107
0109:  MOVF   1A,W
010A:  MOVWF  34
....................    
....................    if(dato_rx=='j')
010B:  MOVF   34,W
010C:  SUBLW  6A
010D:  BTFSS  03.2
010E:  GOTO   11D
....................    {
....................         porcentaje = getc();
010F:  BTFSS  0C.5
0110:  GOTO   10F
0111:  MOVF   1A,W
0112:  CLRF   5D
0113:  MOVWF  5C
0114:  CALL   0EA
0115:  MOVF   7A,W
0116:  MOVWF  3A
0117:  MOVF   79,W
0118:  MOVWF  39
0119:  MOVF   78,W
011A:  MOVWF  38
011B:  MOVF   77,W
011C:  MOVWF  37
....................    }
011D:  BCF    0C.5
011E:  BCF    0A.3
011F:  BCF    0A.4
0120:  GOTO   035
.................... }
.................... 
.................... void main(){
*
0800:  MOVF   03,W
0801:  ANDLW  1F
0802:  MOVWF  03
0803:  MOVLW  19
0804:  BSF    03.5
0805:  MOVWF  19
0806:  MOVLW  A6
0807:  MOVWF  18
0808:  MOVLW  90
0809:  BCF    03.5
080A:  MOVWF  18
080B:  MOVLW  FF
080C:  MOVWF  2E
080D:  BCF    2F.0
080E:  CLRF   36
080F:  CLRF   35
0810:  CLRF   3E
0811:  CLRF   3D
0812:  CLRF   3C
0813:  CLRF   3B
0814:  MOVLW  0C
0815:  MOVWF  3F
0816:  CLRF   41
0817:  CLRF   40
0818:  BSF    03.5
0819:  BSF    1F.0
081A:  BSF    1F.1
081B:  BSF    1F.2
081C:  BCF    1F.3
081D:  MOVLW  07
081E:  MOVWF  1C
081F:  BCF    03.7
....................    input(PIN_B0);
*
0823:  BSF    03.5
0824:  BSF    06.0
.................... 
....................    lcd_init();
0825:  BCF    0A.3
0826:  BCF    03.5
0827:  GOTO   236
0828:  BSF    0A.3
....................    
....................    output_low(PIN_E0);
0829:  BSF    03.5
082A:  BCF    09.0
082B:  BCF    03.5
082C:  BCF    09.0
....................    output_low(PIN_E1);
082D:  BSF    03.5
082E:  BCF    09.1
082F:  BCF    03.5
0830:  BCF    09.1
....................    
....................    enable_interrupts(INT_EXT);
0831:  BSF    0B.4
....................    
....................    enable_interrupts(INT_RDA);
0832:  BSF    03.5
0833:  BSF    0C.5
....................    
....................    setup_timer_0(RTCC_INTERNAL | RTCC_DIV_256);
0834:  MOVF   01,W
0835:  ANDLW  C0
0836:  IORLW  07
0837:  MOVWF  01
....................    ext_int_edge(H_TO_L);
0838:  BCF    01.6
....................    enable_interrupts(INT_TIMER0);
0839:  BCF    03.5
083A:  BSF    0B.5
....................  
....................    enable_interrupts(GLOBAL);
083B:  MOVLW  C0
083C:  IORWF  0B,F
....................    set_timer0(255);
083D:  MOVLW  FF
083E:  MOVWF  01
....................    
....................    printf(lcd_putc,"AC MOTOR CONTROL \nMax RPM:3500");
083F:  MOVLW  21
0840:  BSF    03.6
0841:  MOVWF  0D
0842:  MOVLW  01
0843:  MOVWF  0F
0844:  BCF    0A.3
0845:  BCF    03.6
0846:  GOTO   2CC
0847:  BSF    0A.3
....................    delay_ms(2500);
0848:  MOVLW  0A
0849:  MOVWF  42
084A:  MOVLW  FA
084B:  MOVWF  50
084C:  BCF    0A.3
084D:  CALL   149
084E:  BSF    0A.3
084F:  DECFSZ 42,F
0850:  GOTO   04A
....................   
....................    while(1){
....................    lcd_gotoxy(1,1);
0851:  MOVLW  01
0852:  MOVWF  50
0853:  MOVWF  51
0854:  BCF    0A.3
0855:  CALL   28E
0856:  BSF    0A.3
....................    printf(lcd_putc,"\fDuty Cicle: %lf \nRPM: %f",porcentaje, RPM);
0857:  MOVLW  31
0858:  BSF    03.6
0859:  MOVWF  0D
085A:  MOVLW  01
085B:  MOVWF  0F
085C:  BCF    03.0
085D:  MOVLW  0D
085E:  BCF    03.6
085F:  MOVWF  42
0860:  BCF    0A.3
0861:  CALL   324
0862:  BSF    0A.3
0863:  MOVLW  89
0864:  MOVWF  04
0865:  MOVF   3A,W
0866:  MOVWF  45
0867:  MOVF   39,W
0868:  MOVWF  44
0869:  MOVF   38,W
086A:  MOVWF  43
086B:  MOVF   37,W
086C:  MOVWF  42
086D:  MOVLW  02
086E:  MOVWF  46
086F:  BCF    0A.3
0870:  CALL   45E
0871:  BSF    0A.3
0872:  MOVLW  39
0873:  BSF    03.6
0874:  MOVWF  0D
0875:  MOVLW  01
0876:  MOVWF  0F
0877:  BCF    03.0
0878:  MOVLW  07
0879:  BCF    03.6
087A:  MOVWF  42
087B:  BCF    0A.3
087C:  CALL   324
087D:  BSF    0A.3
087E:  MOVLW  89
087F:  MOVWF  04
0880:  MOVF   3E,W
0881:  MOVWF  45
0882:  MOVF   3D,W
0883:  MOVWF  44
0884:  MOVF   3C,W
0885:  MOVWF  43
0886:  MOVF   3B,W
0887:  MOVWF  42
0888:  MOVLW  02
0889:  MOVWF  46
088A:  BCF    0A.3
088B:  CALL   45E
088C:  BSF    0A.3
....................    delay_ms(1000);
088D:  MOVLW  04
088E:  MOVWF  42
088F:  MOVLW  FA
0890:  MOVWF  50
0891:  BCF    0A.3
0892:  CALL   149
0893:  BSF    0A.3
0894:  DECFSZ 42,F
0895:  GOTO   08F
0896:  CLRF   2B
0897:  BTFSC  0B.7
0898:  BSF    2B.7
0899:  BCF    0B.7
.................... 
....................    RPM = ((float)contador*60) / (dientes); // Calcular RPM
089A:  MOVF   36,W
089B:  MOVWF  5D
089C:  MOVF   35,W
089D:  MOVWF  5C
089E:  BCF    0A.3
089F:  CALL   0EA
08A0:  BSF    0A.3
08A1:  BTFSC  2B.7
08A2:  BSF    0B.7
08A3:  MOVF   7A,W
08A4:  MOVWF  45
08A5:  MOVF   79,W
08A6:  MOVWF  44
08A7:  MOVF   78,W
08A8:  MOVWF  43
08A9:  MOVF   77,W
08AA:  MOVWF  42
08AB:  MOVF   45,W
08AC:  MOVWF  52
08AD:  MOVF   44,W
08AE:  MOVWF  51
08AF:  MOVF   43,W
08B0:  MOVWF  50
08B1:  MOVF   42,W
08B2:  MOVWF  4F
08B3:  CLRF   56
08B4:  CLRF   55
08B5:  MOVLW  70
08B6:  MOVWF  54
08B7:  MOVLW  84
08B8:  MOVWF  53
08B9:  BCF    0A.3
08BA:  CALL   37B
08BB:  BSF    0A.3
08BC:  MOVF   7A,W
08BD:  MOVWF  45
08BE:  MOVF   79,W
08BF:  MOVWF  44
08C0:  MOVF   78,W
08C1:  MOVWF  43
08C2:  MOVF   77,W
08C3:  MOVWF  42
08C4:  CLRF   2B
08C5:  BTFSC  0B.7
08C6:  BSF    2B.7
08C7:  BCF    0B.7
08C8:  CLRF   5D
08C9:  MOVF   3F,W
08CA:  MOVWF  5C
08CB:  BCF    0A.3
08CC:  CALL   0EA
08CD:  BSF    0A.3
08CE:  BTFSC  2B.7
08CF:  BSF    0B.7
08D0:  MOVF   45,W
08D1:  MOVWF  49
08D2:  MOVF   44,W
08D3:  MOVWF  48
08D4:  MOVF   43,W
08D5:  MOVWF  47
08D6:  MOVF   42,W
08D7:  MOVWF  46
08D8:  MOVF   7A,W
08D9:  MOVWF  4D
08DA:  MOVF   79,W
08DB:  MOVWF  4C
08DC:  MOVF   78,W
08DD:  MOVWF  4B
08DE:  MOVF   77,W
08DF:  MOVWF  4A
08E0:  BCF    0A.3
08E1:  CALL   521
08E2:  BSF    0A.3
08E3:  MOVF   7A,W
08E4:  MOVWF  3E
08E5:  MOVF   79,W
08E6:  MOVWF  3D
08E7:  MOVF   78,W
08E8:  MOVWF  3C
08E9:  MOVF   77,W
08EA:  MOVWF  3B
....................    printf("%f", RPM);
08EB:  MOVLW  89
08EC:  MOVWF  04
08ED:  MOVF   3E,W
08EE:  MOVWF  45
08EF:  MOVF   3D,W
08F0:  MOVWF  44
08F1:  MOVF   3C,W
08F2:  MOVWF  43
08F3:  MOVF   3B,W
08F4:  MOVWF  42
08F5:  MOVLW  02
08F6:  MOVWF  46
08F7:  BCF    0A.3
08F8:  GOTO   5EB
08F9:  BSF    0A.3
....................    
....................    lcd_gotoxy(1,1);
08FA:  MOVLW  01
08FB:  MOVWF  50
08FC:  MOVWF  51
08FD:  BCF    0A.3
08FE:  CALL   28E
08FF:  BSF    0A.3
....................    printf(lcd_putc,"\fDC: %lf \nRPM: %f1.1",porcentaje, RPM);
0900:  MOVLW  3E
0901:  BSF    03.6
0902:  MOVWF  0D
0903:  MOVLW  01
0904:  MOVWF  0F
0905:  BCF    03.0
0906:  MOVLW  05
0907:  BCF    03.6
0908:  MOVWF  42
0909:  BCF    0A.3
090A:  CALL   324
090B:  BSF    0A.3
090C:  MOVLW  89
090D:  MOVWF  04
090E:  MOVF   3A,W
090F:  MOVWF  45
0910:  MOVF   39,W
0911:  MOVWF  44
0912:  MOVF   38,W
0913:  MOVWF  43
0914:  MOVF   37,W
0915:  MOVWF  42
0916:  MOVLW  02
0917:  MOVWF  46
0918:  BCF    0A.3
0919:  CALL   45E
091A:  BSF    0A.3
091B:  MOVLW  42
091C:  BSF    03.6
091D:  MOVWF  0D
091E:  MOVLW  01
091F:  MOVWF  0F
0920:  BCF    03.0
0921:  MOVLW  07
0922:  BCF    03.6
0923:  MOVWF  42
0924:  BCF    0A.3
0925:  CALL   324
0926:  BSF    0A.3
0927:  MOVLW  89
0928:  MOVWF  04
0929:  MOVF   3E,W
092A:  MOVWF  45
092B:  MOVF   3D,W
092C:  MOVWF  44
092D:  MOVF   3C,W
092E:  MOVWF  43
092F:  MOVF   3B,W
0930:  MOVWF  42
0931:  MOVLW  02
0932:  MOVWF  46
0933:  BCF    0A.3
0934:  CALL   45E
0935:  BSF    0A.3
0936:  MOVLW  31
0937:  MOVWF  4F
0938:  BCF    0A.3
0939:  CALL   2A0
093A:  BSF    0A.3
093B:  MOVLW  2E
093C:  MOVWF  4F
093D:  BCF    0A.3
093E:  CALL   2A0
093F:  BSF    0A.3
0940:  MOVLW  31
0941:  MOVWF  4F
0942:  BCF    0A.3
0943:  CALL   2A0
0944:  BSF    0A.3
....................    
....................    contador=0;
0945:  CLRF   36
0946:  CLRF   35
....................  
....................    T_LOW= (int16)(((float)porcentaje*255.0)/100);
0947:  MOVF   3A,W
0948:  MOVWF  52
0949:  MOVF   39,W
094A:  MOVWF  51
094B:  MOVF   38,W
094C:  MOVWF  50
094D:  MOVF   37,W
094E:  MOVWF  4F
094F:  CLRF   56
0950:  CLRF   55
0951:  MOVLW  7F
0952:  MOVWF  54
0953:  MOVLW  86
0954:  MOVWF  53
0955:  BCF    0A.3
0956:  CALL   37B
0957:  BSF    0A.3
0958:  MOVF   7A,W
0959:  MOVWF  45
095A:  MOVF   79,W
095B:  MOVWF  44
095C:  MOVF   78,W
095D:  MOVWF  43
095E:  MOVF   77,W
095F:  MOVWF  42
0960:  MOVF   45,W
0961:  MOVWF  49
0962:  MOVF   44,W
0963:  MOVWF  48
0964:  MOVF   43,W
0965:  MOVWF  47
0966:  MOVF   42,W
0967:  MOVWF  46
0968:  CLRF   4D
0969:  CLRF   4C
096A:  MOVLW  48
096B:  MOVWF  4B
096C:  MOVLW  85
096D:  MOVWF  4A
096E:  BCF    0A.3
096F:  CALL   521
0970:  BSF    0A.3
0971:  MOVF   7A,W
0972:  MOVWF  45
0973:  MOVF   79,W
0974:  MOVWF  44
0975:  MOVF   78,W
0976:  MOVWF  43
0977:  MOVF   77,W
0978:  MOVWF  42
0979:  BCF    0A.3
097A:  GOTO   6B4
097B:  BSF    0A.3
097C:  MOVF   79,W
097D:  MOVWF  33
097E:  MOVF   78,W
097F:  MOVWF  32
....................    T_HIGH =255-T_LOW;
0980:  MOVF   32,W
0981:  SUBLW  FF
0982:  MOVWF  30
0983:  CLRF   31
0984:  MOVF   33,W
0985:  BTFSS  03.0
0986:  INCFSZ 33,W
0987:  SUBWF  31,F
0988:  GOTO   051
....................   }
.................... }
0989:  SLEEP

Configuration Fuses:
   Word  1: 3F32   HS NOWDT PUT NOBROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
